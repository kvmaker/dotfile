#+TITLE:     设备分析
#+AUTHOR:    yubo y00186361
#+EMAIL:     kvmaker.yubo@huawei.com
#+DATE:      Wed Jun  4 13:58:03 2014
#+LATEX_CLASS: cn-article
#+BEAMER_FRAME_LEVEL: 2
#+LaTeX_CLASS_OPTIONS: [xcolor=svgnames,bigger,presentation]
#+OPTIONS: LaTeX:dvipng
#+STARTUP: showall

* 设备管理配置
** NTP
*** 介绍
- 定义：NTP用于在一系列分布式时间服务器与客户端之间同步时钟。
- 目的：NTP主要应用于网络中所有设备时钟需要保持一致的场合
  1. 网络管理
  2. 计费系统：要求所有设备的时钟保持一致。
  3. 多个系统协同处理同一个复杂事件：为保证正确的执行顺序，多个系统必须参考同一时钟。
  4. 备份服务器和客户机之间进行增量备份：要求备份服务器和所有客户机之间的时钟同步。
  5. 系统时间：某些应用程序需要知道用户登录系统的时间以及文件修改的时间。
- 版本
- 原理
  #+CAPTION: NTP原理
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/ntp0.png]]
  1. RouterA发送一个NTP报文给RouterB，该报文中带有它离开RouterA时的时间戳10:00:00a.m.（T1）。
  2. 此NTP报文到达RouterB时，RouterB加上到达时间戳11:00:01a.m.（T2）。
  3. 此NTP报文离开RouterB时，RouterB再加上离开时间戳11:00:02a.m.（T3）。
  4. RouterA接收到该响应报文时，加上新的时间戳10:00:03a.m.（T4）。
  5. 至此，RouterA获得了足够信息来计算以下两个重要参数：
     - NTP报文来回一个周期的时延：Delay= ( T4 - T1 ) - ( T3 – T2 )。
     - RouterA相对RouterB的时间差：Offset= ( ( T2- T1 ) + ( T3 – T4 ) ) / 2。
     - RouterA根据计算得到Delay为2秒，Offset为1小时。RouterA根据这些信息来设定自己的时
       钟，实现与RouterB的时钟同步。
- 网络结构
  #+CAPTION: NTP网络结构
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/ntp1.png]]
  1. 同步子网
  2. 主服务器
  3. 二级服务器
  4. 层数
- 工作模式
  1. 单播服务器/客户端模式
  2. 对等体模式
  3. 广播模式
  4. 组播模式
  5. 多播模式
- 访问控制
  1. 访问权限
  2. KOD
  3. 认证
*** 开源方案
- ntpdate
  手动同步系统时间
  #+begin_src sh
  # 同步华为内部时间服务器
  ntpdate szxntp01-in.huawei.com
  ntpdate szxntp02-in.huawei.com
  #+end_src
- ntpd
  ntpd配置
  #+begin_src sh
  /etc/ntp.conf

  # 同步服务器
  server szxntp01-in.huawei.com
  server szxntp02-in.huawei.com
  #+end_src
- ntp-keygen
  用于生成ntp需要的公钥和私钥
*** 结论
- 开源方案支持单播，广播，组播等工作模式。
- 开源方案支持访问控制。
- 开源方案支持NTP服务器和客户端。
- 开源方案支持基于共享密钥的安全和非对称密钥的安全。

* 接口管理配置
** Ethernet
- 公共(ifconfig)
  1. MAC
     #+begin_src sh
     ifconfig eth0 hw ether 00:00:00:00:00:01
	 #+end_src
  2. MTU
	 #+begin_src sh
     ifconfig eth0 mtu 1200
     #+end_src
- 私有
  1. 速率（10M，100M, 1000M）
  2. 模式（半双公， 全双工）
  3. Checksum Offload
  4. 流量控制
  5. 帧间隙
  6. 私有控制命令
  7. 出/入带宽利用率日志和告警阈值
  8. 端口隔离
  9. 配置环回检测
** Serial
- 物理属性(<termios.h>)
  1. 波特率
  2. 数据位
  3. 停止位
  4. 奇偶校验位
  5. 流控
- 链路层协议
  1. PPP(pppd, pppoe-server)
  2. HDLC, FR(sethdlc)
** CE1/PRI
- 历史
  - 20世纪60年代，随着PCM（Pulse Code Modulation）技术的出现，TDM（Time
    Division Multiplexing）技术在数字通信系统中逐渐得到广泛的应用。目前，在
    数字通信系统中存在两种时分复用系统，一种是ITU-T推荐的E1系统，广泛应用于
    欧洲以及中国；一种是由ANSI推荐的T1系统，主要应用于北美和日本（日本采用
    的J1，与T1基本相似，可以算作T1系统）。
- 物理属性
  1. 时钟模式(主，从)
  2. 帧格式（CRC4, 非CRC4）
  3. 线路空闲码（0x7e， 0xff）
  4. 帧间填充
- E1
  1. 数据带宽为2.048Mbit/s的接口
  2. 支持PPP, HDLC, FR
- CE1
  1. 2M的传输线路分成了32个64K的时隙
  2. 0号时隙由于传输同步信息
  3. 各个时隙对应一个接口
  4. 支持PPP, HDLC, FR
- PRI
  1. 2M的传输线路分成了32个64K的时隙
  2. 0号时隙由于传输同步信息
  3. 时隙16被作为D信道来传输信令
  4. 其它时隙与16好组合作为ISDN PRI使用
  5. 支持PPP, HDLC, FR
** 3G
- 使用数据卡
- 标准(WCDMA, CDMA2000)
- APN(Access Point Name)
  1. 单APN
  2. 多APN
- MTU
- PIN管理功能
** LTE
- 使用数据卡
** WLAN
- MAC
- 模式（802.1g, 802.11n, 802.11ac等）
- 频宽（40M, 20M）
- 工作频率(2.4G, 5G, 2.4G+5G)
- SSID
- Channel
** PON
- 光模块参数
- 认证(MAC, SN, LLID...)

** 其它
- CT1/PRI：T1系统的物理接口
- CE3: E3系统的物理接口
- E1-F: 简化版的CE1/PRI接口
- T1-F: 简化版的TE1/PRI接口
- ISDN BRI
- POS
- CPOS
- ADSL
- VDSL

** 逻辑接口
*** PPP（链路协议，L2TP, PPTP VPN）
   #+begin_src sh
   pppd nic-eth0 user xxx password xxx
   #+end_src
*** HDLC && FR
   #+begin_src sh
   sethdlc
   #+end_src
*** Tunnel
- IPv4 over IPv6, IPv6 over IPv4（IPv6过渡技术）
  #+begin_src sh
  ip -4 tunnel add sit
  ip -6 tunnel add 6rd
  #+end_src
- IPv4 over IPv4, IPv6 over IPv6（IPSec VPN）
  #+begin_src sh
  ip -4 tunnel add ipip
  ip -6 tunnel add ipip
  #+end_src
- GRE
  #+begin_src sh
  ip -4 tunnel add gre
  #+end_src
- VLAN
  #+begin_src sh
  vconfig add eth0 100
  vconfig set_egress_map eth0-100 3
  vconfig set_ingress_map eth0-100 2
  #+end_src
- Bridge
  #+begin_src sh
  brctl add br0
  brctl addif br0 lan0
  brctl addif br0 lan1
  #+end_src
- VXLAN
  #+begin_src sh
  ip link add vxlan0 type vxlan id 42 dev eth1
  #+end_src
*** VLAN
- PORT类型：access，trunk, hybrid
  Linux是trunk
- 隔离物理端口
  #+begin_src sh
  vconfig add eth0 100
  vconfig add eth1 100
  vconfig add eth2 200
  vconfig add eth3 200
  brctl addbr br0
  brctl addif br0 eth0.100 
  brctl addif br0 eth1.100
  brctl addbr br1
  brctl addif br1 eth2.200
  brctl addif br1 eth3.200
  #+end_src
- 实现不同VLAN的通讯
  #+begin_src sh
  ifconfig br0 10.0.0.0/24
  ifconfig br1 20.0.0.0/24
  #+end_src
- VLAN聚合
  Linux不支持
- QinQ
  不支持
  支持双层VLAN
- VLAN-Mapping
  不支持
- 考虑ovs
*** MPLS
- https://github.com/i-maravic/MPLS-Linux
- https://github.com/i-maravic/iproute2
- 独立的开发版本，实验性质的版本, 没有融入主分支。
- 没有LDP支持，所以只能支持静态LSP。
- 举例
  #+begin_src ditaa :file ./temp/mpls.png
    +--------+             +---------+             +---------+
    |        |             |         |             |         |
    | LER1   |  192.168.2.2|  LSR    |  192.168.3.3|  LER2   | 10.0.0.0/24
----+        +-------------+         +-------------+         +------------
    |        |    [200]    |         |    [300]    |         |           
    +--------+             +---------+             +---------+
  #+end_src
  
  #+begin_src sh
    LER1:    
    ip link add mpls1 type mpls push 200 192.168.2.2
    ip route add 10.0.0.0/24 dev mpls1
    LSR:
    ip route add 200 mpls swap 300 dev eth0 192.168.3.3
    LER2:
    ip route add 10.0.0.0/24 mpls pop
  #+end_src

* 以太网交换配置
** MAC表
*** 介绍
- MAC地址表
  1. 基于MAC地址转发
  2. MAC地址表分类：
	 - 动态地址表
     - 静态地址表
     - 黑洞表项
- 关闭学习MAC能力，限制MAC地址数
  由于MAC表的容量是有限的，当黑客伪造大量源MAC地址不同的报文并发送到设备后，设备
  上的MAC地址表项资源可能会被耗尽。此时即使它收到正常的报文，也无法学习到报文中
  的源MAC地。
  1. 基于VLAN或接口关闭学习MAC能力。
  2. 基于VLAN或接口进行MAC地址数限制。
- 端口安全
  端口安全（Port Security）功能将设备接口学习到的MAC地址变为安全MAC地址（包括安
  全动态MAC和Sticky MAC），可以阻止除安全MAC和静态MAC之外的主机通过本接口和设备
  通信，从而增强设备安全性。
  1. 安全动态MAC地址：使能端口安全而未使能Sticky MAC功能时学习到的MAC地址。缺省情况
     下，安全动态MAC地址不会被老化，设备重启后安全动态MAC地址会丢失，需要重新学习。
  2. Sticky MAC地址：使能端口安全后又使能Sticky MAC功能后学习到的MAC地址。Sticky MAC
	 地址不会被老化，保存配置后重启设备，Sticky MAC地址不会丢失，无需重新学习。
- MAC地址漂移
  #+CAPTION: MAC地址漂移
  #+ATTR_LaTeX: widht=.6\textwidth
  [[./fig/mac_table.png]]
  若SwitchB和SwitchC之间误接网线，则Router、SwitchB、SwitchC之间形成环路。当
  SwitchA上Port1接口从网络中收到一个广播报文后转发给Router，该报文经过环路，会被
  SwitchA上Port2接口收到。在接口Port2上配置MAC地址漂移检测，此时SwitchA会感知到
  MAC地址学习接口跳变的现象。若连续出现此现象，则在SwitchA上可以判断出现了MAC地
  址漂移。

** 以太网链路聚合
*** 介绍
- 定义：
  链路聚合（Link Aggregation）是将多条物理链路捆绑在一起成为一条逻辑链路，从而增
  加链路带宽的技术。
  #+CAPTION: Eth-Trunk示意图
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/eth_trunk0.png]]
- 转发原理
  #+CAPTION: Eth-Trunk转发原理
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/eth_trunk1.png]]
- LACP

** VLAN
*** 介绍
- 定义：
  VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑
  上划分成多个广播域的通信技术。VLAN内的主机间可以直接通信，而VLAN间不能直接互通，
  从而将广播报文限制在一个VLAN内。  
- 目的：
  以太网是一种基于CSMA/CD（Carrier Sense Multiple Access/Collision Detection）的共
  享通讯介质的数据网络通讯技术。当主机数目较多时会导致冲突严重、广播泛滥、性能显著
  下降甚至造成网络不可用等问题。通过交换机实现LAN互连虽然可以解决冲突严重的问题，
  但仍然不能隔离广播报文和提升网络质量。
  在这种情况下出现了VLAN技术，这种技术可以把一个LAN划分成多个逻辑的VLAN，每个VLAN
  是一个广播域，VLAN内的主机间通信就和在一个LAN内一样，而VLAN间则不能直接互通，这
  样，广播报文就被限制在一个VLAN内。
  #+CAPTION: VLAN示意图
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/vlan0.png]]
- VLAN Aggregation
  1. 背景：交换网络中，VLAN技术以其对广播域的灵活控制和部署方便而得到了广泛的应
     用。但是在一般的三层交换机中，通常是采用一个VLAN对应一个三层逻辑接口的方式
     实现广播域之间的互通，这样导致了IP地址的浪费。
	 #+CAPTION: VLAN Aggregaton
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/vlan1.png]]
  2. 实现原理
	 #+CAPTION: VLAN Aggregation原理
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/vlan2.png]]
  3. VLAN间通信: ARP-Proxy
- VLAN Damping：
  当使能VLAN Damping功能，VLAN中最后一个处于Up状态的接口变为Down后，会抑制一定时
  间（抑制时间可配置）再上报给VLANIF接口。
  #+CAPTION: VLAN Damping
  #+ATTR_LaTeX: scale=0.75
  #+begin_src ditaa :file temp/vlan_damping.png
                 +---------+
                 |         |
                 | VLANIF  |
                 +-+-+-+-+-+
                   | | | |
       +-----------+ | | +-----------+
       |         +---+ +---+         |
       |         |         |         |
       |         |         |         |
    +--+--+   +--+--+   +--+--+   +--+--+
    |     |   |     |   |     |   |     |
    |port1|   |port2|   |port3|   |port4|
    +-----+   +-----+   +-----+   +-----+
  #+end_src
*** 开源方案

** QinQ
*** 介绍
- 定义：
  QinQ（802.1Q-in-802.1Q）技术是一项扩展VLAN空间的技术，通过在802.1Q标签报
  文的基础上再增加一层802.1Q的Tag来达到扩展VLAN空间的功能，可以使私网VLAN透传公
  网。由于在骨干网中传递的报文有两层802.1Q Tag（一层公网Tag，一层私网Tag），即
  802.1Q-in-802.1Q，所以称之为QinQ协议。
- 价值：
  扩展VLAN，对用户进行隔离和标识不再受到限制。
  QinQ内外层标签可以代表不同的信息，如内层标签代表用户，外层标签代表业务，更利于业
  务的部署。QinQ封装、终结的方式很丰富，帮助运营商实现业务精细化运营。
- 基本QinQ
  #+CAPTION: 基本QinQ
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/qinq0.png]]
  企业A内部存在不同业务，因此划分了不同VLAN。在CE设备的运营商侧配置基本QinQ功能，
  为通过该接口的报文统一添加VLAN ID为20的外层VLAN Tag，到达另一分支时统一剥掉外
  层VLAN Tag。这样两分支之间的流量就可以在公网中透明传输，使企业A两分支相同业务
  可以互通，不同业务之间互相隔离。
- 灵活QinQ
  #+CAPTION: 灵活QinQ
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/qinq1.png]]
  对进入二层QinQ接口的帧，可以根据不同的内层Tag而加上不同的外层Tag，对于用户VLAN
  的划分更加细致。
*** 开源方案
** VLAN Mapping
*** 介绍
- 定义：
  VLAN Mapping通过修改报文携带的VLAN Tag来实现不同VLAN的相互映射。
- 目的：
  在某些场景中，两个VLAN相同的二层用户网络通过骨干网络互联，为了实现用户之间的二
  层互通，以及二层协议（例如MSTP等）的统一部署，需要实现两个用户网络的无缝连接，
  此时就需要骨干网可以传输来自用户网络的二层VLAN报文。而在通常情况下，骨干网的
  VLAN规划和用户网络的VLAN规划是不一致的，所以在骨干网中无法直接传输用户网络的
  VLAN报文。
  解决这个问题的方法有两个，其中一个是通过QinQ或者VPLS等二层隧道技术，将用户VLAN报
  文封装在骨干网报文中进行传输，可以实现用户VLAN报文的透传。但是这种方法一方面需要
  增加额外的报文开销（增加一层封装），另外一方面，二层隧道技术可能会对某些二层协议
  报文的透传支持不是非常完善。另外一种方法就是通过VLAN Mapping技术，一侧用户网络的
  VLAN报文进入骨干网后，骨干网边缘设备将用户网络的VLAN（C-VLAN）修改为骨干网中可以
  识别和承载的VLAN（S-VLAN），传输到另一侧之后，边缘设备再将S-VLAN修改为C-VLAN。这
  样就可以很好的实现两个用户网络二层无缝连接。
  在另一种场景中，如果由于规划的差异，导致两个直接相连的二层网络中部署的VLAN ID不
  一致。但是用户又希望可以把两个网络作为单个二层网络进行统一管理，例如用户二层互通
  和二层协议的统一部署。此时也可以在连接两个网络的交换机上部署VLAN Mapping功能，实
  现两个网络之间不同VLAN ID的映射，达到二层互通和统一管理的目的。
- 应用场景：
  1. 基于VLAN ID的Mapping
	 #+CAPTION: VLAN ID的Mapping
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/vlanmapping0.png]]

  2. 基于802.1Q优先级的Mapping
	 #+CAPTION: 基于801.1Q优先级的Mapping
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/vlanmapping1.png]]
*** 开源方案

** GVRP
*** 介绍
- 作用：
  GARP协议主要用于建立一种属性传递扩散的机制，以保证协议实体能够注册和注销该属性。
  GARP作为一个属性注册协议的载体，可以用来传播属性。将GARP协议报文的内容映射成不
  同的属性即可支持不同上层协议应用。
  GVRP是GARP的一种应用，用于注册和注销VLAN属性。
  GARP协议通过目的MAC地址区分不同的应用。在IEEE Std 802.1Q中将01-80-C2-00-00-21分
  配给VLAN应用，即GVRP。
** STP
*** 介绍
- 定义：以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路。但
  是使用冗余链路会在交换网络上产生环路，引发广播风暴以及MAC地址表不稳定等故障现
  象，从而导致用户通信质量较差，甚至通信中断。为解决交换网络中的环路问题，提出了
  生成树协议STP（Spanning Tree Protocol）。
- 背景：
  #+CAPTION: STP背景
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/stp0.png]]
  1. 广播风暴导致网络不可用。
  2. MAC地址表震荡导致MAC地址表项被破坏。
- 基本概念：
  #+CAPTION: STP基本概念
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/stp1.png]]
  1. 根桥
  2. 根端口
  3. 指定端口
- 拓扑计算
  1. 初始状态
  2. 选择根桥
  3. 选择根端口和指定端口

** MSTP
* 广域网互联
** DCC
*** 介绍
- 定义：
  拨号控制中心DCC（Dial Control Center）是指路由器之间通过ISDN网络、3G网络等进行
  互联时或者路由器作为PPPoE/PPPoEoA/PPPoA Client与PPPoE/PPPoEoA/PPPoA Server之间
  互联时所采用的技术，DCC主要提供按需拨号服务。
- 目的：
  由于某些场合下，路由器之间仅在有数据需要传送时才建立连接并通信，传送的信息具有
  时间不相关性、突发性、总体数据量小等特点，DCC为此种应用提供了灵活、经济、高效
  的解决方案。
  实际应用中，DCC主要应用于以下两种场景：
  1. 以备份形式为干线通讯提供保障，在干线因为线路或其它原因出现故障而不能正常
     通信时，提供替代的辅助通路，确保业务正常进行。
  2. 当路由器作为PPPoE/PPPoEoA/PPPoA Client时，DCC通过按需拨号的功能，
	 为用户节省费用。
- 受益：DCC特性给企业用户带来了如下的受益。
  1. 费用的节省：路由器之间不预先建立连接，当它们之间有数据需要传送时才以拨号的方式建
	 立连接，当连接再次空闲，DCC会切断当前的连接，以节省用户的费用。
  2. 通讯保障：DCC作为干线备份为用户提供了通讯保障，在干线因为线路或其它原因出现故障
	 而不能正常通信时，提供替代的辅助通路，确保业务正常进行运转。
  3. 灵活的部属：共享DCC可以使物理接口根据连接选择不同的工作参数，从而实现一口多用。
- 应用场景
  1. 通过接口备份实现主干线路通信备份
	 #+CAPTION: DCC备份线路
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/dcc0.png]]
  2. 当路由器作为PPPoE/PPPoEoA/PPPoA Client时，DCC通过按需拨号的功能，为用户节省
     费用
	 #+CAPTION: DCC按需拨号
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/dcc1.png]]
- 开源方案
  无

*** 开源方案
- pppd
  #+begin_src sh
  # 设置ppp连接如果多长时间没有数据后，自动断开。
  pppd idle n
  #+end_src

** PPP
*** 介绍
- 定义：
  PPP（Point-to-Point Protocol）协议是一种点到点链路层协议，主要用于在全双工的同
  异步链路上进行点到点的数据传输。
- 优点
  1. 对物理层而言，PPP既支持同步链路又支持异步链路，而X.25、FR（Frame Relay）等
	 数据链路层协议仅支持同步链路，SLIP仅支持异步链路。
  2. PPP协议具有良好的扩展性，例如，当需要在以太网链路上承载PPP协议时，PPP可以
	 扩展为PPPoE。
  3. 提供LCP（Link Control Protocol）协议，用于各种链路层参数的协商。
  4. 提供各种NCP（Network Control Protocol）协议（如IPCP、IPXCP），用于各网络层
	 参数的协商，更好地支持了网络层协议。
  5. 提供认证协议CHAP（Challenge-Handshake Authentication Protocol）、
	 PAP（Password Authentication Protocol），更好的保证了网络的安全性。
  6. 无重传机制，网络开销小，速度快。
- 建链过程：
  #+CAPTION: PPP建链过程
  #+begin_src ditaa :file temp/ppp0.png
    +----------+          +-------------+        +---------------+
    |          |    UP    |             | OPENED |               |       
    | Dead     +--------->| Establish   +------->| Authenticate  +-------+
    +----------+          +-----+-------+        +------+--------+       |
         ^                      |                       |                |
         |       FAIL           |                       |                |
         |<---------------------+            FAIL       |            SUCC|
         |                            +-----------------+                |
         |                            |                                  |
         |     +--------------+       |      +----------------+          |
         |     |              |       v      |                |          |
         +-----+ Terminate    |<-------------+ Netowrk        |<---------+
         DOWN  +--------------+   CLOSING    +----------------+
  #+end_src
- 应用场景
  #+CAPTION: PPP应用场景
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/ppp0.png]]
*** 开源方案
- pppd
  1. 介绍：
	 pppd配合Linux内核的ppp驱动完成，ppp链路的建立，维护PPP链路。
	 #+begin_src sh
     pppd [ options ]
	 #+end_src
  2. 选项
     |--------------------------+------------------------------------------|
     | 选项                     | 说明                                     |
     |--------------------------+------------------------------------------|
     | _ttyname_                | 使用串口设备与对端通讯                   |
     | _speed_                  | 串口设备的速率                           |
     | _asyncmp_                | 使用异步设备的时候，设置其不使用的控制字 |
     | *auth*                   | 使用认证                                 |
     | *call* _name_            | 从/etc/ppp/peer/ _name_ 读取options      |
     | *connect* _script_       | 建立PPP链接前，运行 _script_ 脚本        |
     | *defaultroute*           | 建立连接后，增加一条默认路由             |
     | *disconnect* _script_    | 端口PPP链接后，运行 _script_ 脚本        |
     | *escape* _xx,yy,..._     | 传输时需要忽略的字符                     |
     | *file* _name_            | 从文件 _name_ 获取options                |
     | *init* _script_          | 执行 _script_ 脚本去配置串口             |
     | *lock*                   | 创建一个lock文件来锁定串口               |
     | *mru* _n_                | 设置LCP协商的mru                         |
     | *mtu* _n_                | 设置LCP协商的mtu                         |
     | *passive*                | PPPD主动发起链接                         |
     |--------------------------+------------------------------------------|
     | _<rip>_ : _<lip>_        | 设置IPCP协商的IP地址                     |
     | *+ipv6*                  | 使能IPv6CP                               |
     | *ipv6* _<lid>_ , _<rid>_ | 设置IPv6CP协商的IP地址                   |
     | *allow-ip* _address_     | 使能对端使用这些IP而不需要认证           |
     | *basdcomp* _nr,nt_       | 使能BSD压缩策略                          |
     | *chap-interval* _n_      | 设置CHAP协议重认证间隔                   |
     | *idle* _n_               | 当链路空闲超过 _n_ 秒后主动断开链路      |
     | *ipcp-accept-local*      | 接收对端发送的LOCAL地址请求              |
     | *ipc-accept-remote*      | 接收对端发送的RMOTE（它自己）地址请求    |
     | *lcp-echo-interval* _n_  | 设置LCP-ECHO的时间间隔                   |
     | *mp*                     | 使能PPP多链路功能                        |
     | *noauth*                 | 不认证                                   |
     | *password* _pwd_         | 设置认证密码                             |
     | *pty* _script_           | 使用 _scrip_ 作为通讯设备                |
     | *user* _name_            | 设置认证用户名                           |
     |--------------------------+------------------------------------------|
  3. 选项文件：
	 在执行命令行选项前，首先从/etc/ppp/options, ~/.ppprc ,
     /etc/ppp/options.ttyname读取选项。
- pppoe
  1. 介绍：配合pppd，提供PPPoE客户端的介入功能。
	 #+begin_src sh
     pppd pty 'pppoe [pppoe_options]' [pppd_options]
     pppoe -A [pppoe_options]
	 #+end_src

	 #+CAPTION: PPPoE会话建立过程
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/ppp1.png]]

  2. 选项
     |---------------------+----------------------------------|
     | 选项                | 说明                             |
     |---------------------+----------------------------------|
     | *-I* _interface_    | 设置使用的以太网设备             |
     | *-T* _timeout_      | 设值链路空闲多长时间后，自动断开 |
     | *-S* _service_name_ | 设置service name                 |
     | *-C* _ac_name_      | 设置ac name                      |
     | *-U*                | 使用host unqiue                  |
     |---------------------+----------------------------------|
- pppoe-server
  1. 介绍：配合pppd，完成PPPoE服务器功能
	 #+begin_src sh
     pppoe-server [options]
	 #+end_src
  2. 选项
     |------------------+----------------------------|
     | 选项             | 说明                       |
     |------------------+----------------------------|
     | *-F*             | 设置pppoe-server在前台运行 |
     | *-I* _interface_ | 设置运行在那个接口         |
     | *-C* _ac_name_   | 设置 ac_name               |
     | *-S* _name_      | 设置 server name           |
     | *-L* _ip_        | 设置本地IP地址             |
     | *-R* _ip_        | 设置远端IP地址             |
     |------------------+----------------------------|
	 
** ATM
** 帧中继
** HDLC
** IP-Trunk
** ISDN
** Moderm
** RTC
* IP业务
** IPv4基础
*** 介绍
- IPv4（Internet Protocol Version 4）协议族是TCP/IP协议族中最为核心的协议族。它工
  作在TCP/IP协议栈的网络层，该层与OSI参考模型的网络层相对应。网络层提供了无连接数
  据传输服务，即网络在发送分组时不需要先建立连接，每一个分组（也就是IP数据报文）独
  立发送，与前后的分组无关。
*** 开源方案
- ifconfig
  #+begin_src sh
  ifconfig eth0 192.168.0.100/24
  #+end_src
- iproute2
  #+begin_src sh
  ip -4 addr add 192.168.0.100/24 dev eth0
  #+end_src
** ARP
*** 介绍
- 定义
  - 地址解析协议ARP（Address Resolution Protocol）是用来将IP地址解析为MAC地址的
    协议。
- 目的
  - 在局域网中，当主机或其它网络设备有数据要发送给另一个主机或设备时，它必须知道对方
    的网络层地址（即IP地址）。但是仅有IP地址是不够的，因为IP数据报文必须封装成帧才能
    通过物理网络发送，因此发送方还必须有接收方的物理地址（MAC地址），所以需要一个从
    IP地址到物理地址的映射。ARP就是实现这个功能的协议。
- 基本原理
  #+CAPTION: ARP原理
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/arp0.png]]
  #+CAPTION: ARP原理
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/arp1.png]]
- Proxy ARP
  1. 路由式Proxy ARP: 使那些在同一网段却不在同一物理网络上的网络设备能够相互通信的一种功能。
     #+CAPTION: 路由Proxy ARP
     #+ATTR_LATEX: width=.6\textwidth
     [[./fig/proxy_arp0.png]]
  2. VLAN内Proxy ARP: 如果两个用户属于相同的VLAN，但VLAN内配置了用户隔离。此时用户间要互通，需要
     在关联了VLAN的接口上启动VLAN内Proxy ARP功能。
     #+CAPTION: VLAN内Proxy APR
     #+ATTR_LATEX: width=.6\textwidth
     [[./fig/proxy_arp1.png]]
  3. VLAN间Proxy ARP: 如果两个用户属于不同的VLAN，用户间要进行三层互通，可以在关
     联了VLAN的接口上启动VLAN间Proxy ARP功能。
     #+CAPTION: VLAN间Proxy ARP
     #+ATTR_LATEX: width=.6\textwidth
     [[./fig/proxy_arp2.png]]
- 免费ARP
  1. 主机主动使用自己的IP地址作为目标地址发送ARP请求。
  2. 作用：
	 - 检查重复的IP地址。
	 - 通告新的MAC地址。
	 - 在VRRP备份组中用来通告主备发生变换。
- ARP-Ping
  - ARP-Ping IP
  - ARP-Ping MAC
*** 开源方案
- 动态ARP
- 静态ARP
  #+begin_src sh
  # 添加表项
  ip -4 neigh add 192.168.1.1 00:00:00:00:00:01 dev eth0

  # 删除表项
  ip -4 neigh del 192.168.1.1 00:00:00:00:00:01 dev eth0

  # 查看表项
  ip -4 neigh show
  #+end_src
- ARP-Proxy
- ARP-Ping IP
  #+begin_src sh
  arping 192.168.1.1
  #+end_src
- ARP-Ping MAC
  不支持

** DHCP
*** 介绍
- 定义：动态主机配置协议DHCP（Dynamic Host Configuration Protocol）是一种用于集
  中对用户IP地址进行动态管理和配置的技术。
- 目的：
  1. DHCP实现了IP地址及网络配置参数的自动分配的功能。
  2. DHCP实现了IP地址及网络配置参数的自动分配的功能。
- 基本架构
  #+CAPTION: DHCP基本架构
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/dhcp0.png]]
  1. DHCP Client：DHCP客户端，通过与DHCP服务器进行报文交互，获取IP地址和其他网络
	 配置信息，完成自身的地址配置。在设备接口上配置DHCP Client功能，这样接口可以作为
	 DHCP Client，使用DHCP协议从DHCP Server动态获得IP地址等参数，方便用户配置，
	 也便于集中管理。
  2. DHCP Relay：DHCP中继，负责转发来自客户端方向或服务器方向的DHCP报文，协助
	 DHCP客户端和DHCP服务器完成地址配置功能。如果DHCP服务器和DHCP客户端不在同一
     个网段范围内，则需要通过DHCP中继来转发报文，这样可以避免在每个网段范围内都
	 部署DHCP服务器，既节省了成本，又便于进行集中管理。在DHCP基本协议架构中，
	 DHCP中继不是必须的角色。只有当DHCP客户端和DHCP服务器不在同一网段内，
	 才需要DHCP中继进行报文的转发。
  3. DHCP Server：DHCP服务器，负责处理来自客户端或中继的地址分配、地址续租、
	 地址释放等请求，为客户端分配IP地址和其他网络配置信息。
- 应用场景
  #+CAPTION: DHCP Server的典型组网应用
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/dhcp1.png]]

  #+CAPTION: DHCP Relay的典型组网应
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/dhcp2.png]]

  #+CAPTION: DHCP/BOOTP Client的典型组网应用
  #+ATTR_LATEX: width=.6\textwidth
  [[./fig/dhcp3.png]]

*** 开源方案
- http://www.isc.org/downloads/dhcp/
- dhclent
  1. 操作：启动时通过制定-4或-6来开启DHCPv4或DHCPv6。通过读取dhclient.conf
	 获取到需要启动dhcp clent的接口和参数。使用dhclient.lease来跟踪获取到的
	 IP地址。
  2. 命令行：当命令行没有指定接口名称，dhclient.conf中也没有指定是，dhclient
	 默认工作在所有接口上。
  3. 选项：
     |-----------------+------------------------------------------|
     | 选项            | 说明                                     |
     |-----------------+------------------------------------------|
     | -4              | 使用DHCPv4协议                           |
     | -6              | 使用DHCPv6协议                           |
     | -l              | 强制获取一次租期，如果失败返回2          |
     | -d              | 运行在前台                               |
     | -nw             | 成为一个daemon                           |
     | -q              | 静默模式，不输出任何信息。默认选项       |
     | -v              | 输出信息                                 |
     | -w              | 即使没有找到广播接口，也继续运行         |
     | -n              | 不要配置任务接口，与-w一起使用           |
     | -e              | 自定义环境变量                           |
     | -r              | 释放当前地址                             |
     | -x              | 退出dhcp clent                           |
     | -p port         | 使用udp端口port，默认使用68              |
     | -s server       | 指定DHCP Server地址                      |
     | -g relay        | 指定DHCP Realy地址                       |
     | --version       | 输出版本信息                             |
     | -cf confgi-file | 指定配置文件                             |
     | -lf lease-file  | 指定lease文件                            |
     | -pf pid-file    | 指定pid记录文件                          |
     | --no-pid        | 没有pid记录文件                          |
     | -sf script-file | 指定获取到租期后执行的脚本文件。默认使用 |
     |                 | BINDDIR/dhclient-script                  |
     |-----------------+------------------------------------------|
  4. dhclient.conf
     |----------------------------+----------------------------------------|
     | 选项                       | 说明                                   |
     |----------------------------+----------------------------------------|
     | *timout* _time_            | 设定超时时间。                         |
     | *retry* _time_             | 设定没有服务器时的重试次数。           |
     | *select-time* _time_       | 设定select时间。                       |
     | *reboot* _time_            | 设定reboot时间。                       |
     | *initital-interval* _time_ | 设定初始化间隔。                       |
     | *request* _option_ [, ...] | 设定客户端需要请求的option。           |
     | *require* _option_ [, ...] | 设定客户端需要请求的option，如果其中有 |
     |                            | option没有在offer中，则忽略此offer。   |
     | *send* _option_            | 设定客户端发送给服务器的option。       |
     |----------------------------+----------------------------------------|
	 #+begin_src sh
       timeout 300;
       retry 60;
       reboot 10;
       select-timeout 5;
       initial-interval 2;
       reject 192.33.137.209;

       interface "ep0" {
           send host-name "andare.fugue.com";
           send dhcp-client-identifier 1:0:a0:24:ab:fb:9c;
           send dhcp-lease-time 3600;
           supersede domain-search "fugue.com", "rc.vix.com", "home.vix.com";
           prepend domain-name-servers 127.0.0.1;
           request subnet-mask, broadcast-address, time-offset, routers,
                domain-name, domain-name-servers, host-name;
           require subnet-mask, domain-name-servers;
           script "CLIENTBINDIR/dhclient-script";
           media "media 10baseT/UTP", "media 10base2/BNC";
       }

       alias {
         interface "ep0";
         fixed-address 192.5.5.213;
         option subnet-mask 255.255.255.255;
       }
	 #+end_src
- dhcpd
- dhrelay
  
** DNS
*** 介绍
- 定义：
  域名系统DNS（Domain Name System）是一种用于TCP/IP应用程序的分布式数据库，
  提供域名与IP地址之间的转换服务。
- 作用：
  网络中的每台主机都是由IP地址来标识的，用户只有获得待访问主机的IP地址才能够
  成功实现访问操作。对于用户来讲，记住主机的IP地址是相当困难的，因此设计了一
  种字符串形式的主机命名机制，这些主机名与IP地址一一对应，这就是域名系统。域
  名系统解决了IP地址信息不便于记忆这一问题。用户进行访问网络主机操作时，可以
  直接使用便于记忆的、有意义的域名，由网络中的域名解析服务器将域名解析为正确
  的IP地址。
- 工作原理：
  DNS域名解析分为静态域名解析和动态域名解析，二者可以配合使用。在解析域名时，首
  先采用静态域名解析（查找静态域名解析表），如果静态域名解析不成功，再采用动态域
  名解析。由于动态域名解析可能会花费一定的时间，且需要域名服务器的配合，因而可以
  将一些常用的域名放入静态域名解析表中，这样可以大大提高域名解析效率。
  1. 静态DNS
  2. 动态DNS
	 #+CAPTION: 动态DNS
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/dns0.png]]
  3. DDNS
	 - RFC2136定义的DDNS更新方式：设备作为DDNS客户端，动态更新DNS服务器中域名和
       IP地址的映射关系。
     - 通过DDNS服务器实现的更新方式：设备作为DDNS客户端，将域名与IP地址的映射
       关系发送给指定URL地址的DDNS服务器，然后DDNS服务器通知DNS服务器动态更新
       域名和IP地址之间的映射关系
	   #+CAPTION: 动态DNS
	   #+ATTR_LaTeX: width=.6\textwidth
       [[./fig/dns4.png]]
- DNS Proxy/Relay工作原理
  #+CAPTION: DNS Proxy工作原理
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/dns1.png]]
  1. DNS Client将DNS请求报文发送给DNS Proxy，即请求报文的目的地址为DNS Proxy的IP地址。
  2. DNS Proxy收到请求报文后，首先查找本地的域名解析表，如果存在请求的信息，则DNS
  3. Proxy直接通过DNS应答报文将域名解析结果返回给DNS Client。
  4. 如果不存在请求的信息，则DNS Proxy将报文转发给DNS Server，通过DNS Server进行域名解析。
  5. DNS Proxy收到DNS Server的应答报文后，记录域名解析的结果，并将报文转发给DNS Client。
- 应用场景
  #+CAPTION: DNS Client场景
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/dns2.png]]
  #+CAPTION: DNS Proxy场景
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/dns3.png]]
*** 开源方案
- nslookup
  1. 作用：用于查询主机的IP地址
  2. 用法
   #+begin_src sh
   nslookup [-option] [name | -] [server]
   #+end_src
   当出现如下情况时，nslookup进入交互模式，交互模式下允许用户多次查询。
   #+begin_src sh
yubo@u1:~/work/org/op-analyse/fig$ nslookup
> www.baidu.com
Server:         10.72.55.81
Address:        10.72.55.81#53

Non-authoritative answer:
www.baidu.com   canonical name = www.a.shifen.com.
Name:   www.a.shifen.com
Address: 61.135.169.125
Name:   www.a.shifen.com
Address: 61.135.169.105
> www.huawei.com
Server:         10.72.55.81
Address:        10.72.55.81#53

Non-authoritative answer:
Name:   www.huawei.com
Address: 10.82.49.59
#+end_src
  3. 当没有给出参数时。
  4. 当第一个参数是-, 第二个参数是一个主机名或IP地址。
- /etc/resolv.conf
  1. 作用：主机的DNS解析配置
  2. 用法：
   |-------------------------------------+----------------------------------------------|
   | 选项                                | 说明                                         |
   |-------------------------------------+----------------------------------------------|
   | *nameserver* Name Server IP address | 服务器地址，可以配置多个，解析是顺序查找     |
   | *domain* Local domain name          | 配置域名称                                   |
   | *search* List for host-name         | 对于没有给出域的名称，一次使用List中的域查找 |
   |-------------------------------------+----------------------------------------------|
  3. 举例：
     #+begin_src sh
nameserver 10.72.55.81
nameserver 10.72.255.100
nameserver 10.98.48.39
search huawei.com
     #+end_src
- /etc/hosts
  1. 作用：配置静态解析地址
  2. 举例：
	 #+begin_src sh
127.0.0.1       localhost
127.0.1.1       u1
10.67.226.203   u0

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
	 #+end_src
- dnsmasq
  1. 作用：DNS缓存服务器。

** NAT
*** 介绍
- 定义：
  网络地址转换NAT（Network Address Translation）是将IP数据报报头中的IP地址
  转换为另一个IP地址的过程。
- 目的：
  随着Internet的发展和网络应用的增多，IPv4地址枯竭已成为制约网络发展的瓶颈。尽管
  IPv6可以从根本上解决IPv4地址空间不足问题，但目前众多网络设备和网络应用大多是基于
  IPv4的，因此在IPv6广泛应用之前，一些过渡技术（如CIDR、私网地址等）的使用是解决这
  个问题最主要的技术手段。NAT主要用于实现内部网络（简称内网，使用私有IP地址）访问
  外部网络（简称外网，使用公有IP地址）的功能。当内网的主机要访问外网时，通过NAT技
  术可以将其私网地址转换为公网地址，可以实现多个私网用户共用一个公网地址来访问外部
  网络，这样既可保证网络互通，又节省了公网地址。
- 概述：
  1. Basic NAT
	 #+CAPTION: Basic NAT
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/nat0.png]]
  2. NAPT
	 #+CAPTION: NAPT
	 #+ATTR_LaTeX: width=.6\textwidth
	 [[./fig/nat1.png]]
- NAT ALG
  1. 说明：
  NAT和NAPT只能对IP报文的头部地址和TCP/UDP头部的端口信息进行转换。对于一些特殊协
  议，例如FTP等，它们报文的数据部分可能包含IP地址信息或者端口信息，这些内容不能
  被NAT有效的转换。解决这些特殊协议的NAT转换问题的方法就是在NAT实现中使用应用层
  网关ALG（Application Level Gateway）功能。ALG是对特定的应用层协议进行转换，在
  对这些特定的应用层协议进行NAT转换过程中，通过NAT的状态信息来改变封装在IP报文数
  据部分中的特定数据，最终使应用层协议可以跨越不同范围运行。
  1. 部分需要做ALG的协议
     |----------+----------------------------------------------------|
     | 应用协议 | 做NAT变换的字段                                    |
     |----------+----------------------------------------------------|
     | DNS      | 响应报文中的IP和Port                               |
     | FTP      | - Port请求报文中载荷里的IP和Port                   |
     |          | - Passive响应报文中载荷里的IP和Port                |
     | SIP      | - Request line                                     |
     |          | - From                                             |
     |          | - Via                                              |
     |          | - O                                                |
     |          | - Message body的C字段地址和M字段的端口             |
     | PPTP     | 分PPTP Client在私网还是PPTP Server在私网两种场景： |
     |          | - PPTP Client在私网，PPTP Server在公网时，         |
     |          |   仅对Client-Call-ID进行端口替换                   |
     |          | - PPTP Server在私网，PPTP Client在公网时，         |
     |          |   仅对Server-Call-ID进行端口替换                   |
     | RTSP     | setup/reply OK 报文中的端口字段                    |
     |----------+----------------------------------------------------|
- DNS Mapping
  #+CAPTION: DNS Mapping
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/nat2.png]]
- NAT关联VPN
- 两次NAT
- NAT过滤和映射方式
- 典型应用
  - 私网主机访问公网
	#+CAPTION: 私网主机访问公网
	#+ATTR_LaTeX: width=.6\textwidth
	[[./fig/nat3.png]]
  - 公网主机访问私网
	#+CAPTION: 公网主机访问私网
	#+ATTR_LaTeX: width=.6\textwidth
	[[./fig/nat4.png]]
  - 私网主机通过域名访问公网
	#+CAPTION: 私网主机通过域名访问公网
	#+ATTR_LaTeX: width=.6\textwidth
	[[./fig/nat5.png]]
  - NAT多实例
	#+CAPTION: NAT多实例
	#+ATTR_LaTeX: width=.6\textwidth
	[[./fig/nat6.png]]
*** 开源方案
- Netfilter
  Linux内核态实现的状态防火墙，其中包括NAT功能。
- iptables
  用户态配置防火墙的工具。
  - SNAT
	#+CAPTION: SNAT
	#+ATTR_LaTeX: width = .6\textwidth
	#+begin_src ditaa :file temp/nat7.png
  +-----+              +------+
  |     |     LAN      |      | WAN
  |Host +------------->|Router+------>
  +-----+  10.0.0.0/24 +------+ 192.168.1.1                
  10.0.0.1             
	#+end_src
	#+begin_src sh
    iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -j SNAT --to 192.168.1.1
	#+end_src
  - DNAT
	#+CAPTION: DNAT
	#+ATTR_LaTeX: width=.6\textwidth
	#+begin_src ditaa :file temp/nat8.png
  +-----+              +------+
  |     |      LAN     |      | WAN
  |Host |<-------------+Router|<-----
  +-----+  10.0.0.0/24 +------+ 192.168.1.1:8080
  10.0.0.1:8080                
	#+end_src
	#+begin_src sh
    iptables -t nat -A PREROUTING -p tcp -d 192.168.1.1:8080 --dport 8080 -j DNAT --to 10.0.0.1:8080
	#+end_src
- ALG
  - Netifiler的ALG: tftp, ftp, sip, h232, gre, ipsec, pptp, dccp, sctp

** TODO UDP Helper
*** 介绍
- 背景：网络中的主机有时需要向服务器发送UDP广播报文，用以获取网络配置或解析网络
  主机名等。但是，如果主机和服务器不在同一个广播域时，无法利用UDP广播报文进行通
  信，主机就无法从服务器获取所需要的信息。
  为解决上述问题，路由器提供了UDP Helper功能。通过该功能可以对目的端口为指定端口的
  UDP广播报文进行中继转发，将广播报文转换为单播报文发送给指定的目的服务器。	
*** 开源方案
	
** IP性能
*** 介绍
    |------------------------------------+----------|
    | 参数                               | 缺省配置 |
    |------------------------------------+----------|
    | IP源地址校验功能                   | 未使能   |
    | 出接口IP报文强制分片功能           | 未使能   |
    | ping快回功能                       | 使能     |
    | 业务接口板丢弃TTL=1的ICMP报文功能  | 未使能   |
    | 业务接口板丢弃带选项的ICMP报文功能 | 未使能   |
    | 丢弃目的不可达ICMP报文功能         | 未使能   |
    | SYN-Wait定时器                     | 75秒     |
    | FIN-Wait定时器                     | 675秒    |
    | TCP window-size                    | 8k字节   |
    |------------------------------------+----------|
*** 开源方案
** IPv6基础
   参考IPv4地址配置
** DHCPv6
   参考DHCP配置
** IPv6 DNS
   参考DNS配置
** IPv6 over IPv4隧道
   参考逻辑接口配置
** IPv4 over IPv6隧道
   参考逻辑接口配置
   
* IP单播路由配置
** IP路由
*** 原理描述
- 路由器及路由基本原理
- 静态路由与动态路由
- 路由表和FIB表
- 路由协议的优先级
- 路由的度量
  1. 路径长度
  2. 网络带宽
  3. 负载
  4. 通信开销
- 负载分担与路由备份
- IP FRR
  快速重路由FRR（Fast Reroute）是指当物理层或链路层检测到故障时将故障消息上报至
  上层路由系统，并立即启用一条备份链路转发报文。IP FRR是一种快速实现路由备份的方
  式。
- 缺省路由
- 自治系统
** 静态路由
*** 介绍
- 定义：静态路由是一种需要管理员手工配置的特殊路由。
- 目的：
  1. 当网络结构比较简单时，只需配置静态路由就可以使网络正常工作。
  2. 在复杂网络环境中，配置静态路由可以改进网络的性能，并可为重要的应用保证带宽。
  3. 静态路由可在VPN实例中使用，主要用于VPN路由的管理。
- 基础：
  1. 目的地址和掩码
  2. 出接口和下一跳地址
  3. 静态路由优先级
- 应用场景：
  #+CAPTION: 负载分担
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/route0.png]]
  #+CAPTION: 路由备份
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/route1.png]]
  #+CAPTION: 静态缺省路由
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/route2.png]]
*** 开源方案
- route
  #+begin_src sh
  /*显示路由表*/
  yubo@u1:~$ route
  Kernel IP routing table
  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
  default         10.68.166.1     0.0.0.0         UG    0      0        0 eth0
  10.68.166.0     *               255.255.254.0   U     1      0        0 eth0
  link-local      *               255.255.0.0     U     1000   0        0 eth0
  192.168.1.0     *               255.255.255.0   U     0      0        0 eth1

  /*添加路由表项*/
  yubo@u1:~$ sudo route add -net 192.168.2.0 netmask 255.255.255.0 gw 192.168.1.100
  yubo@u1:~$ route
  Kernel IP routing table
  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
  default         10.68.166.1     0.0.0.0         UG    0      0        0 eth0
  10.68.166.0     *               255.255.254.0   U     1      0        0 eth0
  link-local      *               255.255.0.0     U     1000   0        0 eth0
  192.168.1.0     *               255.255.255.0   U     0      0        0 eth1
  192.168.2.0     192.168.1.100   255.255.255.0   UG    0      0        0 eth1

  /*删除路由表*/
  yubo@u1:~$ sudo route del -net 192.168.2.0 netmask 255.255.255.0 gw 192.168.1.100 dev eth1
  yubo@u1:~$ route
  Kernel IP routing table
  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
  default         10.68.166.1     0.0.0.0         UG    0      0        0 eth0
  10.68.166.0     *               255.255.254.0   U     1      0        0 eth0
  link-local      *               255.255.0.0     U     1000   0        0 eth0
  192.168.1.0     *               255.255.255.0   U     0      0        0 eth1
  #+end_src
- ip
  #+begin_src sh
  /*显示路由表*/
  yubo@u1:~$ ip route
  default via 10.68.166.1 dev eth0  proto static
  10.68.166.0/23 dev eth0  proto kernel  scope link  src 10.68.167.208  metric 1
  169.254.0.0/16 dev eth0  scope link  metric 1000
  192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.1

  /*添加路由表*/
  yubo@u1:~$ sudo ip route add 192.168.2.0/24 via 192.168.1.100 dev eth1
  yubo@u1:~$ sudo ip route
  default via 10.68.166.1 dev eth0  proto static
  10.68.166.0/23 dev eth0  proto kernel  scope link  src 10.68.167.208  metric 1
  169.254.0.0/16 dev eth0  scope link  metric 1000
  192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.1
  192.168.2.0/24 via 192.168.1.100 dev eth1

  /*删除路由表*/
  yubo@u1:~$ sudo ip route del 192.168.2.0/24 via 192.168.1.100 dev eth1
  yubo@u1:~$ sudo ip route
  default via 10.68.166.1 dev eth0  proto static
  10.68.166.0/23 dev eth0  proto kernel  scope link  src 10.68.167.208  metric 1
  169.254.0.0/16 dev eth0  scope link  metric 1000
  192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.1
  192.168.2.0/24 via 192.168.1.100 dev eth1
  #+end_src
- ecmp
  #+begin_src sh
  /*配置两条等价路由，按照3：7分担流量*/
  yubo@u1:~$ sudo ip -4 route add 192.168.2.0/24 nexthop via 192.168.1.100 dev eth1 weight 3 nexthop via 192.168.1.101 dev eth1 weight 7
  yubo@u1:~$ sudo ip -4 route
  default via 10.68.166.1 dev eth0  proto static
  10.68.166.0/23 dev eth0  proto kernel  scope link  src 10.68.167.208  metric 1
  169.254.0.0/16 dev eth0  scope link  metric 1000
  192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.1
  192.168.2.0/24
          nexthop via 192.168.1.100  dev eth1 weight 3
          nexthop via 192.168.1.101  dev eth1 weight 7
  #+end_src
  由于Linux内核使用了路由缓存，可能导致实际流量并不能完全按照3：7分配。

** RIP
*** 介绍
- 定义：RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop
  Count）作为度量来衡量到达目的网络的距离。
- 目的：由于RIP的实现较为简单，在配置和维护管理方面也远比OSPF和IS-IS容易，因此
  RIP主要应用于规模较小的网络中。
- 基本原理
  #+CAPTION: RIP基本原理
  #+ATTR_LaTeX: width=.6\textwidth
  [[./fig/rip0.png]]
  1. RIP协议启动之后，RouterA会向相邻的路由器广播一个Request报文。
  2. 当RouterB从接口接收到RouterA发送的Request报文后，把自己的RIP路由表封装在Respone
	 报文内，然后向该接口对应的网络广播。
  3. RouterA根据RouterB发送的Response报文，形成自己的路由表。
- RIP2的增强特性
  1. 支持外部路由标记（Route Tag）。
  2. 支持CIDR。
  3. 支持指定下一跳，在广播网上可以选择到目的网段最优下一跳地址。
  4. 支持以组播方式发送更新报文。
  5. 支持对协议报文进行验证。
  6. 支持路由聚合。
- 水平分割与毒性反转
  1. 水平分割：水平分割（Split Horizon）的原理是，RIP从某个接口学到的路由，不会
     从该接口再发回给邻居路由器。
	 #+CAPTION: RIP水平分割
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/rip1.png]]
  2. 毒性反转：毒性反转（Poison Reverse）的原理是，RIP从某个接口学到路由后，从原
	 接口发回邻居路由器，并将该路由的开销设置为16（即指明该路由不可达）。利用这
	 种方式，可以清除对方路由表中的无用路由。
	 #+CAPTION: RIP毒性反转
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/rip2.png]]
- 对进程与多实例
- RIP与BFD联动
- RIP NSR（Non-stop Routing）
  通过NSR特性，RIP将所有与路由有关的数据从主用主控板AMB（Active Main Board）备份
  到备用主控板SMB（Standby Main Board）。所以无论何时主用主控板出现故障，备用主
  控板都会变成激活状态，接替主控板工作。由于主备板采取高度同步的方式，所以发生倒
  换时邻居不会感知到本设备故障，因此保持了业务在整网中的平稳运行。
*** 开源方案
- quagga总体
  1. 介绍：quagga支持包括RIPv1, RIPv2, RIPng, OSPFv2, OSPFv3, IS-IS, BGP-4, 
	 BPG-4+协议的路由服务。
  2. 架构
	 #+CAPTION: Quagga系统架构
	 #+ATTR_LaTeX: width=.8\textwidth
	 #+begin_src ditaa :file temp/guagga0.png
     +----+  +----+  +-----+  +-----+
     |bgpd|  |ripd|  |ospfd|  |zebra|
     +----+  +----+  +-----+  +--+--+
                                 |
     +---------------------------|--+
     |                           v  |
     |  Kernel  routing table       |
     |                              |
     +------------------------------+
	 #+end_src
	 - 提供一个统一的与内核进行对接的管理者zebra，所有的路由协议都是通过zebra来
	   与内核路由表交互。
	 - 不通的路由进程可以部署在不同的机器上，甚至，同一个机器上可以部署多个相同
       的路由进程。
	 - 提供一个统一的用户管理界面vtysh。
  3. 安装
	 #+begin_src sh
     yubo@u1:~/download/quagga-0.99.22$ ./configure --enable-vtysh
     yubo@u1:~/download/quagga-0.88.22$ make
     yubo@u1:~/download/quagga-0.88.22$ make install
     #+end_src
	 将如下内容添加到/etc/services
	 #+begin_src sh
     zebrasrv      2600/tcp  # zebra service
     zebra         2601/tcp  # zebra vty
     ripd          2602/tcp  # RIPd vty
     ripngd        2603/tcp  # RIPngd vty
     ospfd         2604/tcp  # OSPFd vty
     bgpd          2605/tcp  # BGPd vty
     ospf6d        2606/tcp  # OSPF6d vty
     ospfapi       2607/tcp  # ospfapi
     isisd         2608/tcp  # ISISd vty
	 #+end_src
  4. 权限配置 && 添加用户
	 #+begin_src sh
     yubo@u1:~$ sudo groupadd quaggga
     yubo@u1:~$ sudo useradd quaggga -g quaggga
     yubo@u1:~$ sudo chown quaggga:quaggga /var/run/
     yubo@u1:~$ sudo chmod 777 /var/run/ 
	 #+end_src
- zebra
  1. 开启zebra
	 #+begin_src sh
     yubo@u1:~/$ sudo zebra -f /etc/quagga/zebra.conf -d
     yubo@u1:~$ cat /etc/quagga/zebra.conf
     hostname u1
     log stdout
     password zebra
     enable password zebra
	 #+end_src
  2. 进入zebra
     #+begin_src sh
	 yubo@u1:~$ telnet localhost 2601
     Trying 127.0.0.1...
     Connected to localhost.
     Escape character is '^]'.

     Hello, this is Quagga (version 0.99.22).
     Copyright 1996-2005 Kunihiro Ishiguro, et al.

     User Access Verification
      
     Password:
     Password:
     u1>
	 #+end_src
  3. 进入config模式
	 #+begin_src sh
     u1> enable
     Password:
     u1# configure terminal
     u1(config)#
	 #+end_src
  4. Interface命令：
	 参考[quagga_doc]4.2
	 #+begin_src sh
     u1(config)# interface eth1
     u1(config-if)# ip add
     u1(config-if)# ip address 192.168.1.200/24
	 #+end_src
  5. 静态路由命令：
	 参考[quagga_doc]4.3
	 #+begin_src sh
     u1(config)# ip route 192.168.3.0/24 192.168.1.100
	 #+end_src
- ripd
  1. 开启ripd
	 #+begin_src sh
     yubo@u1:~$ sudo ripd -f /etc/quagga/ripd.conf -d
     yubo@u1:~$ cat /etc/quagga/ripd.conf
     hostname u1
     log stdout
     password ripd
     enable password ripd
	 #+end_src
  2. 实验拓扑
	 #+CAPTION: RIP实验拓扑
	 #+ATTR_LaTeX: width=.8\textwidth
	 #+begin_src ditaa :file temp/rip1.png
                 +------+      +------+       +-------+                +-----+
                 |      |      |HuaWei|       |       |                |     |         
          -------+  u0  +-=----+Net   +-=-----+   u1  +----------------+  R  +----(192.168.2.0/24)    
                 +------+      +------+       +-------+                +--+--+                    
       192.168.0.0/24                                   192.168.1.0/24    |                       
                                                                          |                       
                                                                   (192.168.3.0/24)               
                                                                          |                       
	 #+end_src
  3. 配置
	 - u0
	   #+begin_src sh
       # 建立到达u1的隧道
       yubo@u0:~$ ip tunnel add ipip mode ipip local 10.67.226.203 remote 10.68.167.208 ttl 255
       yubo@u0:~$ ip addr add 192.168.10.100 peer 192.168.10.101 dev ipip

       # 配置ripd
       yubo@u0:~$ telnet localhost 2602
       Trying 127.0.0.1...
       Connected to localhost.
       Escape character is '^]'.

       Hello, this is Quagga (version 0.99.22).
       Copyright 1996-2005 Kunihiro Ishiguro, et al.


       User Access Verification

       Password:
       u0-ripd> enable
       Password:
       u0-ripd# configure terminal
       u0-ripd(config)# router rip
       u0-ripd(config-router)# network ipip
       There is a same network configuration ipip
       u0-ripd(config-router)# network eth1
       There is a same network configuration eth1
	   #+end_src
     - u1
	   #+begin_src sh
       # 建立达到u0的隧道
       yubo@u1:~$ ip tunnel add ipip mode ipip remote 10.67.226.203 local 10.68.167.208 ttl 255
       yubo@u1:~$ ip addr add 192.168.10.101 peer 192.168.10.100 dev ipip

       # 配置ripd
       yubo@u1:~$ telnet localhost 2602
       Trying 127.0.0.1...
       Connected to localhost.
       Escape character is '^]'.

       Hello, this is Quagga (version 0.99.22).
       Copyright 1996-2005 Kunihiro Ishiguro, et al.


       User Access Verification

       Password:
       u0-ripd> enable
       Password:
       u0-ripd# configure terminal
       u0-ripd(config)# router rip
       u0-ripd(config-router)# network ipip
       There is a same network configuration ipip
       u0-ripd(config-router)# network eth1
       There is a same network configuration eth1
       
       # 配置zebra，增加静态路由
       yubo@u1:~$ telnet localhost 2601
       Trying 127.0.0.1...
       Connected to localhost.
       Escape character is '^]'.

       Hello, this is Quagga (version 0.99.22).
       Copyright 1996-2005 Kunihiro Ishiguro, et al.


       User Access Verification

       Password:
       u1-zebra> enable
       Password:
       u1-zebra# configure terminal
       u1-zebra(config)# ip route
       u1-zebra(config)# ip route 192.168.2.0/24 192.168.1.200
       u1-zebra(config)# ip route 192.168.3.0/24 192.168.1.200
	   #+end_src
  4. 其他特性
	 - 引入路由：kernel, static, connnected, ospf, bgp。
	 - 路由过滤
	 - Metric设置
	 - 认证
     - 定时器
** OSPF
*** 介绍
- 定义：
  开放式最短路径优先OSPF（Open Shortest Path First）是IETF组织开发的一个基
  于链路状态的内部网关协议（Interior Gateway Protocol）。
  目前针对IPv4协议使用的是OSPF Version 2（RFC2328）；针对IPv6协议使用OSPF Version
  3（RFC2740）。
- 目的：
  1. OSPF采用组播形式收发报文，这样可以减少对其它不运行OSPF路由器的影响。
  2. OSPF支持无类型域间选路（CIDR）。
  3. OSPF支持对等价路由进行负载分担。
  4. OSPF支持报文加密。
- 路由器类型
  #+CAPTION: OSPF的路由器类型
  #+ATTR_LaTeX: scale=0.75
  [[./fig/ospf0.png]]
  1. 区域内路由器（Internal Router）
  2. 区域边界路由器ABR（Area Border Router）
  3. 骨干路由器（Backbone Router）
  4. 自治系统边界路由器ASBR（AS Boundary Router）
- 路由类型
  1. Intra Area
  2. Inter Area
  3. 第一类外部路由（Type1 External）
  4. 第二类外部路由（Type2 External）
- 区域类型
  1. 普通区域
  2. STUB区域
  3. Totally STUB区域
  4. NSSA区域
  5. Totally NSSA区域
- OSPF报文认证
  1. 区域验证方式
  2. 接口验证方式
- OSPF-TE
  #+CAPTION: OSPF-TE
  #+ATTR_LaTeX: scale=0.75
  [[./fig/ospf1.png]]
  在MPLS-TE体系结构中OSPF起到了信息发布组件的作用：
  1. 收集TE相关信息。
  2. 在同一个区域中的各设备间扩散TE信息。
  4. 把同步收集到的TE信息组成流量工程数据库TEDB（TE DataBase）提供给CSPF计算。
- OSPF-VPN
  #+CAPTION: OSPF-VPN
  #+ATTR_LaTeX: scale=0.75
  [[./fig/ospf2.png]]
  1. PE1将CE1上的OSPF路由引入到BGP中，形成BGP VPNv4路由。
  2. PE1通过MP-BGP将这些BGP VPNv4路由发布给PE2。
  3. PE2将BGP VPNv4路由引入到OSPF，再发布给CE3和CE4。
*** 开源方案
- ospfd
  1. 开启ospfd
	 #+begin_src sh
     yubo@u1:~$ sudo ripd -f /etc/quagga/ripd.conf -d
	 #+end_src
  2. 实验拓扑
	 #+CAPTION: OSPF实验拓扑
	 #+ATTR_LaTeX: width=.9\textwidth
	 #+begin_src ditaa :file temp/ospf.png
                 +------+      +------+       +-------+                +-----+
                 |      |      |HuaWei|       |       |                |     |         
          -------+  u0  +-=----+Net   +-=-----+   u1  +----------------+  R  +----(192.168.2.0/24)    
                 +------+      +------+       +-------+                +--+--+                    
       192.168.0.0/24                                   192.168.1.0/24    |                       
                    |                             |                       |
                    :                             :                (192.168.3.0/24)
                    |                             |                       |
                    |                             |
         AREA_2     |         AREA_1              |   AREA_0
                                
	 #+end_src
  3. 配置
	 - u0
	   #+begin_src sh
       Current configuration:
       !
       hostname u0-ospfd
       password ospfd
       enable password ospfd
       log stdout
       !
       !
       !
       interface eth0
       !
       interface eth1
       !
       interface ipip
       !
       interface lo
       !
       interface tunl0
       !
       interface virbr0
       !
       router ospf
        ospf router-id 192.168.10.100
        redistribute connected
        network 192.168.0.0/24 area 0.0.0.2
        network 192.168.10.0/24 area 0.0.0.1
       !
       line vty
       !
       end
	   #+end_src
     - u1
	   #+begin_src sh
       Current configuration:
       !
       hostname u1-ospfd
       password ospfd
       enable password ospfd
       log stdout
       !
       !
       !
       interface eth0
       !
       interface eth1
       !
       interface gre0
       !
       interface ipip
       !
       interface lo
       !
       interface tap0
       !
       interface tunl0
       !
       router ospf
        ospf router-id 192.168.10.101
        redistribute connected
        redistribute static
        network 192.168.1.0/24 area 0.0.0.0
        network 192.168.10.0/24 area 0.0.0.1
       !
       line vty
       !
       end
	   #+end_src
  4. 其他特性
	 - 路由聚合
	 - 认证
	 - 路由引入
     - 优先级
** ISIS
*** 介绍
- 拓扑结构
  #+CAPTION: ISIS的拓扑结构1
  #+ATTR_LaTeX: scale=0.75
  [[./fig/isis0.png]]
  #+CAPTION: ISIS的拓扑结构2
  #+ATTR_LaTeX: scale=0.75
  [[./fig/isis1.png]]
- 基本原理
  IS-IS是一种链路状态路由协议，每一台路由器都会生成一个LSP，它包含了该路由器所有
  使能IS-IS协议接口的链路状态信息。通过跟相邻设备建立IS-IS邻接关系，互相更新本地
  设备的LSDB，可以使得LSDB与整个IS-IS网络的其他设备的LSDB实现同步。然后根据LSDB
  运用SPF算法计算出IS-IS路由。如果此IS-IS路由是到目的地址的最优路由，则此路由会
  下发的IP路由表中，并指导报文的转发。
- 认证
  1. 接口认证：是指使能IS-IS协议的接口以指定方式和密码对Level-1和Level-2的Hello
     报文进行认证。
  2. 区域认证：是指运行IS-IS的区域以指定方式和密码对Level-1的SNP和LSP报文进行认
     证。
  3. 路由域认证：是指运行IS-IS的路由域以指定方式和密码对Level-2的SNP和LSP报文进
     行认证。
- Overload
  IS-IS OverLoad使用IS-IS过载标记位来标识过载状态。IS-IS过载标志位是指IS-IS LSP
  报文中的OL字段。对设备设置过载标志位后，其它设备在进行SPF计算时不会使用这台设
  备做转发，只计算该设备上的直连路由。
  #+CAPTION: ISIS Overload
  #+ATTR_LaTeX: scale=0.75
  [[./fig/isis2.png]]
- TE
- 所实例、多进程
*** 开源方案
无   

** BGP
*** 介绍
- 定义：边界网关协议BGP（Border Gateway Protocol）是一种实现自治系统
  AS（Autonomous System）之间的路由可达，并选择最佳路由的距离矢量路由协议。
- 优点：
  1. BGP采用认证和GTSM的方式，保证了网络的安全性。
  2. BGP提供了丰富的路由策略，能够灵活的进行路由选路，并且能指导邻居按策略发布路由。
  3. BGP提供了路由聚合和路由衰减功能用于防止路由振荡，有效提高了网络的稳定性。
  4. BGP使用TCP作为其传输层协议（端口号为179），并支持BGP与BFD联动、BGP Tracking和
     BGP GR和NSR，提高了网络的可靠性。
  5. 在邻居数目多、路由量大且大部分邻居具有相同出口策略的场景下，BGP使用按组打包技术
	 极大的提高了BGP打包发包性能。
- 基本概念：
  1. 自治系统。
  2. BGP分类：EBGP, IBGP。
	 #+CAPTION: BGP分类
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/bgp0.png]]
  3. 角色：Speaker, Peer。
  4. BGP的路由器号。
- BGP与IGP交互
  1. BGP引入IGP路由。
  2. IGP引入BGP路由。
- BGP安全性
  1. BGP认证：md5， keychain。
  2. BGP GTSM：检测IP报文头中的TTL（time-to-live）值是否在一个预先设置好的特定范
     围内，并对不符合TTL值范围的报文进行允许通过或丢弃的操作。
- 常用属性
  1. Origin：标记路由是如何成为BGP路由的。优先级：IGP > EGP > Incomplete。
  2. AS_Path：按矢量顺序记录了某条路由从本地到目的地址所要经过的所有AS编号。
  3. Next_Hop：记录了路由的下一跳信息。
  4. Local_Pref：表明路由器的BGP优先级，用于判断流量离开AS时的最佳
     路由。
  5. MED：用于判断流量进入AS时的最佳路由
- BGP选择路由的策略
- BGP负载分担
- 路由反射器
  1. 背景：为保证IBGP对等体之间的连通性，需要在IBGP对等体之间建立全连接关系。假
     设在一个AS内部有n台设备，那么建立的IBGP连接数就为n(n-1)/2。当设备数目很多时，
     设备配置将十分复杂，而且配置后网络资源和CPU资源的消耗都很大。在IBGP对等体间
     使用路由反射器可以解决以上问题。
  2. 角色：RR, Client, Non-Client, Originator, Cluster。
     #+CAPTION: 反射器示意图
     #+ATTR_LaTeX: scale=0.75
     [[./fig/bgp1.png]]
  3. 原理：
	 同一集群内的客户机只需要与该集群的RR直接交换路由信息，因此客户机只需要与RR
     之间建立IBGP连接，不需要与其他客户机建立IBGP连接，从而减少了IBGP连接数量。
	 RR向IBGP邻居发布路由规则如下：
	 - 从非客户机学到的路由，发布给所有客户机。
     - 从客户机学到的路由，发布给所有非客户机和客户机（发起此路由的客户机除外）。
     - 从EBGP对等体学到的路由，发布给所有的非客户机和客户机。
  4. 备份路由反射器。
  5. 多集群路由反射器。
- BGP联盟
  1. 定义：联盟将一个AS划分为若干个子AS。每个子AS内部建立IBGP全连接关系，子AS之
     间建立联盟EBGP连接关系，但联盟外部AS仍认为联盟是一个AS。
	 #+CAPTION: BGP联盟
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/bgp2.png]]
- 路由聚合
- 路由衰减
- BGP与BFD联动
  #+CAPTION: BGP与BFD联动
  #+ATTR_LaTeX: scale=0.75
  [[./fig/bgp3.png]]
- BGP Tracking
- BGP GR和NSR
- BGP按组打包
- MP-BGP：传统的BGP-4只能管理IPv4单播路由信息，对于使用其它网络层协议（如IPv6、
  组播等）的应用，在跨AS传播时就受到一定限制。BGP多协议扩展
  MP-BGP（MultiProtocol BGP）就是为了提供对多种网络层协议的支持，对BGP-4进行的扩
  展。目前的MP-BGP标准是RFC4760，使用扩展属性和地址族来实现对IPv6、组播和VPN相关
  内容的支持，BGP协议原有的报文机制和路由机制并没有改变。
*** 开源方案
- bgpd
  1. 开启bgpd
	 #+begin_src sh
     sudo bgpd -f /etc/quagga/bgpd.conf -d
	 #+end_src
  2. 实验拓扑
	 #+CAPTION: BGP实验拓扑
	 #+ATTR_LaTeX: width=.6\textwidth
	 #+begin_src ditaa :file temp/bgp.png
                 +------+      +------+       +-------+                +-----+
                 |      |      |HuaWei|       |       |                |     |         
          -------+  u0  +-=----+Net   +-=-----+   u1  +----------------+  R  +----(192.168.2.0/24)    
                 +------+      +------+       +-------+                +--+--+                    
       192.168.0.0/24                                   192.168.1.0/24    |                       
                                                                          |                       
                                                                   (192.168.3.0/24)               
                                                                          |                       
	 #+end_src
  3. 配置
	 - u0
	   #+begin_src sh
       router bgp 100
        bgp router-id 192.168.10.100
        network 192.168.0.0/24
        redistribute connected metric 100
        neighbor 192.168.10.101 remote-as 101
	   #+end_src
     - u1
	   #+begin_src sh
       router bgp 101
        bgp router-id 192.168.10.101
        network 192.168.1.0/24
        redistribute connected metric 100
        redistribute static
        neighbor 192.168.10.100 remote-as 100
	   #+end_src
  4. 其他特性
	 - Peer Group
	 - BGP Communities Attribute
	 - Route Reflector
	 - Route Server

** 策略路由
*** 介绍
- 目的：传统的路由转发原理是首先根据报文的目的地址查找路由表，然后进行报文转发。
  但是目前越来越多的用户希望能够在传统路由转发的基础上根据自己定义的策略进行报文
  转发和选路。策略路由使网络管理者不仅能够根据报文的目的地址，而且能够根据报文的
  源地址、报文大小和链路质量等属性来制定策略路由，以改变数据包转发路径，满足用户
  需求。
- 种类
  1. 本地策略路由：针对本地向外发送的报文。
  2. 接口策略路由：针对转发报文。
  3. 智能策略路由：基于业务需求的策略路由，通过匹配链路质量和网络业务对链路质量的需求，实现智
     能选路
*** 开源方案
- ip rule
  1. 原理
	 1. 使用rule + route table
	 2. 按照优先级依次匹配rule，一旦匹配则使用对应的路由表，若路由表没有匹配的
		项，则继续下一个匹配下一个rule。
  2. 默认rule
	 1. Priority 0, Selector: match any , Action : Lookup local route table.
	 2. Priority 32766, Selector :  match any, Action : Lookup main route table.
	 3. Priority 32767, Selector : match any, Lookup default table. 
  3. 配置举例
	 #+CAPTION: 基于入接口的策略路由
	 #+ATTR_LaTeX: scale=0.75
	 #+begin_src ditaa :file temp/policy_route.png
          +------+
          |      |          
          |HostA +---+      
          +------+   |   IF_1                 
                     +------+------+  WAN1    
                            |      +---------->
                            |Router+---------->
          +------+   +------+------+  WAN2
          |      |   |   IF_2
          |HostB +---+
          +------+
	 #+end_src
	 #+begin_src sh
     echo 200 T1 >> /etc/iprotue2/rt_tables
     echo 201 T2 >> /etc/iproute2/rt_tables

     ip route add default dev WAN1 table T1
     ip rule add iif IF_1 table T1

     ip route add default dev WAN2 table T2
     ip rule add iif IF_2 table T2
	 #+end_src
  4. 总结
	 Linux可以基于源地址、目的地址、TOS、OIF、IIF、fwmark进行策略路由。

** 其它开源路由协议实现
- http://bird.network.cz/
- http://www.openbgpd.org/
- http://www.xorp.org/
- http://www.opensourcerouting.org

* IP组播配置
** 组播基础
*** 介绍
- 定义：作为IP传输三种方式之一，IP组播通信指的是IP报文从一个源发出，被转发到一组
  特定的接收者。相较于传统的单播和广播，IP组播可以有效地节约网络带宽、降低网络负
  载，所以被广泛应用于IPTV、实时数据传送和多媒体会议等网络业务中。
- 基本概念
  #+CAPTION: 组播基本概念
  #+ATTR_LaTeX: scale=0.75
  [[./fig/mc0.png]]
  1. 组播源
  2. 组播组
  3. 组播组成员
  4. 组播路由器
- 服务模型
  1. ASM：个组播组地址作为一个网络服务的集合，任何源发布到该组地址的数据得到同样
     的服务。
  2. SSM：SSM模型针对特定源和组的绑定数据流提供服务，接收者主机在加入组播组时，
     可以指定只接收哪些源的数据。
- 组播地址
  - IPv4组播地址
    |-------------------------------------------------------+----------------------------------------|
    | 地址范围                                              | 含义                                   |
    |-------------------------------------------------------+----------------------------------------|
    | 224.0.0.0～224.0.0.255                                | 永久组地址。                           |
    | 224.0.1.0～231.255.255.255 233.0.0.0～238.255.255.255 | ASM组播地址，全网范围内有效。          |
    | 232.0.0.0～232.255.255.255                            | SSM组播地址，全网范围内有效。          |
    | 239.0.0.0～239.255.255.255                            | 本地管理组地址，仅在本地管理域内有效。 |
    |-------------------------------------------------------+----------------------------------------|
  - IPv6组播地址
    |---------------------+-------------|
    | 地址范围            | 含义        |
    |---------------------+-------------|
    | FF0x::/32           | 保留地址    |
    | FF1x::/32 FF2x::/32 | ASM组播地址 |
    | FF3x::/32           | SSM组播地址 |
    |---------------------+-------------|
  - IPv4组播MAC地址
  - IPv6组播MAC地址
- IPv4组播协议
  |---------------------------------------------+------------------------------------------------------------------------------------------|
  | 协议                                        | 说明                                                                                     |
  |---------------------------------------------+------------------------------------------------------------------------------------------|
  | IGMP（Internet Group Management Protocol）  | IGMP协议在主机端实现组播组成员加入与离开，在上游的三层设备中实现组成员关系的维护与管理。 |
  | PIM（Protocol Independent Multicast）       | 主要用于将网络中的组播数据流发送到有组播数据请求的组成员所连接的组播设备上。             |
  | MSDP（Multicast Source Discovery Protocol） | 为了解决多个PIM-SM域之间的互连的一种域间组播协议。                                       |
  | MBGP(Multiprotocol Broder Gateway Protocol) | MBGP实现了跨AS域的组播转发。                                                             |
  | IGMP Snooping                               | 通过侦听上游的三层设备和用户主机之间发送的IGMP报文来建立组播数据报文的二层转发表         |
  |---------------------------------------------+------------------------------------------------------------------------------------------|
- 应用场景
  - 单PIM域内组播
	#+CAPTION: 组播应用场景1
	#+ATTR_LaTeX: scale=0.5
	[[./fig/mc1.png]]
  - 跨PIM-SM域组播
	#+CAPTION: 组播应用场景2
	#+ATTR_LaTeX: scale=0.5
	[[./fig/mc2.png]]
  - 跨AS域组播
	#+CAPTION: 组播应用场景3
	#+ATTR_LaTeX: scale=0.5
	[[./fig/mc3.png]]
*** 开源实现
- Linux
  1. 组播地址和组播路由管理
	 #+begin_src sh
     ip maddr [ add | del ] MULTIADDR dev STRING
     ip mroute show [ dev STRING ]
	 #+end_src
  2. 配置IGMP版本
	 #+begin_src sh
     echo 2 > /proc/sys/net/ipv4/conf/eth0/force_igmp_version
	 #+end_src
  3. 配置响应ICMP Broadcast ECHO
	 #+begin_src sh
     echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
	 #+end_src
- SMCRoute
  1. https://github.com/troglobit/smcroute
  2. 说明：SMCRoute是一个用来维护内核组播路由的工具，支持IPv4和IPv6路由。
     SMCRoute可在小型的组播网络中用来代替mrouted或pimd等动态组播路由工具。
  3. 使用方法
	 #+begin_src sh
     smcroute < options > < commands >

     options
            -d  -  start daemon
            -v  -  verbose output
            -D  -  enable debug logging

     commands - common
            -h  -  print help
            -k  -  kill daemon

     commands - multicast routing related
            -a <InputIntf> <OriginIpAdr> <McGroupAdr> <OutputIntf> [<OutputIntf>] ...
               -  add route
            -r <InputIntf> <OriginIpAdr> <McGroupAdr>
               -  remove route

     commands - multicast signaling related
            -j <InputIntf> <McGroupAdr>  - join MC group
            -l <InputIntf> <McGroupAdr>  - leave MC group
	 #+end_src
  4. 举例
	 #+begin_src ditaa :file temp/smcroute0.png
          u0                       u1                     u2
          +-------+               +--------+              +--------+
          |       |192.168.10.0/24|ipip    |192.168.1.0/24|eth0    |
          |   .100+-----=---------+.101.100+--------------+.200    |
          |   ipip|               |    eth1|              |        |
          +-------+               +--------+              +--------+          
                                                         maddr:239.100.100.100
              
	 #+end_src
	 - u0
	   #+begin_src sh
       ping 239.100.100.100 -I ipip -t 2
	   #+end_src
	 - u1
	   #+begin_src sh
       smcroute -a ipip 192.168.10.100 239.100.100.100 eth1
	   #+end_src
	 - u2
	   #+begin_src sh
       smcroute -j eth0 239.100.100.100
	   #+end_src
- 对比
  |-------------------+------+--------------------|
  | 特性              | AR   | Linux              |
  |-------------------+------+--------------------|
  | ASM               | 支持 | 支持               |
  | SSM               | 支持 | 不完整             |
  | IPv4组播          | 支持 | 支持               |
  | IPv6组播          | 支持 | 支持               |
  | IGMP              | 支持 | 不完整，v3部分支持 |
  | PIM               | 支持 | 支持               |
  | MSDP              | 支持 | 不确定             |
  | MBGP              | 支持 | 不确定             |
  | IGMP/MLD Snooping | 支持 | 支持               |
  |-------------------+------+--------------------|

** IGMP
*** 介绍
- 定义：IGMP用来在接收者主机和与其直接相邻的组播路由器之间建立和维护组播组成员关
  系。
- 目的：
  在组播通信模型中，发送者不关注接收者的位置信息，只是将数据发送到约定的目的组播
  地址。要使组播报文最终能够到达接收者，需要某种机制使连接接收者网段的组播路由器
  能够了解到该网段存在哪些组播接收者，同时保证接收者可以加入相应的组播组中。IGMP
  就是用来在主机和最有一跳路由器间建立这种关系的协议。
  #+CAPTION: IGMP存在的意义
  #+ATTR_LaTeX: scale=0.75
  [[./fig/igmp0.png]]
- 版本：IGMPv1中定义了基本的组成员查询和报告过程，IGMPv2在此基础上添加了查询器选
  举和组成员离开的机制，IGMPv3中增加的主要功能是成员可以指定接收或指定不接收某些
  组播源的报文。
- IGMPv1工作机制
  1. 组播网络。
	 #+CAPTION: 组播网络拓扑
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/igmp1.png]]
  2. 普遍组查询和响应机制：通过普遍组查询和响应，IGMP查询器可以了解到该网段内哪
     些组播组存在成员。
	 #+CAPTION: 普遍组查询与响应
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/igmp2.png]]
  3. 新组成员加入。
	 #+CAPTION: 新成员加入
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/igmp3.png]]
  4. 成员离开机制：IGMPv1没有专门定义离开组的报文。主机离开组播组后，便不会再对
	 普遍组查询报文做出回应。
- IGMPv2增强
  1. 新增成员离开报文，用于快速离开。
  2. 新增特定组查询。
- IGMPv3增强
  1. 新增了特定源组查询报文。
  2. 报告报文不仅包含主机想要加入的组播组，而且包含主机想要接收来自哪些组播源的
     数据。
  3. 在IGMPv3中一个成员报告报文可以携带多个组播组信息。
- IGMP SSM Mapping
  #+CAPTION: SGMP SSM Mapping
  #+ATTR_LaTeX: scale=0.75
  [[./fig/igmp3.png]]
  1. 解决igmpv1, igmpv2无法提供SSM的方法
- IGMP Proxy
  #+CAPTION: IGMP Proxy
  #+ATTR_LaTeX: scale=0.75
  [[./fig/igmp4.png]]
- IGMP Snooping：
  通过侦听三层组播设备和用户主机之间发送的组播协议报文来维护组播报文的出接口信息，
  从而管理和控制组播数据报文在数据链路层的转发。
  #+CAPTION: IGMP Snooping
  #+ATTR_LaTeX: scale=0.75
  [[./fig/igmp5.png]]

*** 开源方案
- IGMP
  1. 代码
	 - Linux 3.14/net/ipv4/igmp.c
	 - Linux 3.14/net/mcast.c
  2. 加入组播组：使用setsockopt()函数设置socket的属性，来实现加入或离开组播组。
	 #+begin_src sh
	 IP_ADD_MEMBERSHIP
	 IP_DROP_MEMBERSHIPIP_DROP_MEMBERSHIP
	 IP_MULTICAST_IF
	 IP_MULTICAST_TTL
	 IP_MULTICAST_LOOP
	 #+end_src
  3. 查看组播组信息
	 #+begin_src sh
     cat /proc/net/igmp
	 #+end_src
- IGMP Snooping
  1. 架构：
	 #+CAPTION: Linux IGMP Snooping
	 #+ATTR_LaTeX: scale=0.75
	 [[./fig/igmp6.png]]
  2. 代码：
     - Linux 3.14/net/bridge/br_multicast.c：监听IGMP/MLD报文。
     - Linux 3.14/net/bridge/br_mdb.c：建立GROUP-PORT数据库。
     |-------------+------+----------------------|
     | 项目        | AR   | Linux                |
     |-------------+------+----------------------|
     | IGMPv1      | 支持 | 支持                 |
     | IGMPv2      | 支持 | 支持                 |
     | IGMPv3      | 支持 | 部分支持， 不支持SSM |
     | SSM Mapping | 支持 | 不支持               |
     |-------------+------+----------------------|
  3. 相关配置
     |--------------------------------------+------------------------|
     | 参数                                 | 说明                   |
     |--------------------------------------+------------------------|
     | /sys/devices/virtual/net/br0/bridge/ |                        |
     | multicast_snooping                   | igmp/mld snooping 开关 |
     | multicast_querier                    | 是否发送query报文      |
     | multicast_querier_*                  | query相关参数          |
     |--------------------------------------+------------------------|
- Mcproxy
  1. 代码
	 https://github.com/mcproxy/mcproxy
- 对比
  |-------------+----+--------|
  | 特性        | AR | Linux  |
  |-------------+----+--------|
  | v1          | Y  | Y      |
  | v2          | Y  | Y      |
  | v3          | Y  | 不完整 |
  | SSM Mapping | Y  | N      |
  | Proxy       | Y  | Y      |
  | Snooping    | Y  | Y      |
  |-------------+----+--------|

** PIM
*** 介绍
- 定义：直接利用单播路由表的路由信息，对组播报文执行RPF（Reverse Path Forwarding，
  逆向路径转发）检查，检查通过后创建组播路由表项，从而转发组播报文。
- 基本概念：
  #+CAPTION: PIM基本概念
  #+ATTR_LaTeX: scale=0.75
  [[./fig/pim0.png]]
  1. 组播分发树：PIM网络以组播组为单位在路由器上建立一点到多点的组播转发路径。
  2. PIM路由器：在接口上使能了PIM协议的路由器即为PIM路由器。
  3. PIM路由表项：PIM路由表项即通过PIM协议建立的组播路由表项。
- PIM-DM
  1. 原理：在实现过程中，它会假设网络中的组成员分布非常稠密，每个网段都可能存在
     组成员。当有活跃的组播源出现时，PIM-DM会将组播源发来的组播报文扩散到整个网
     络的PIM路由器上，再裁剪掉不存在组成员的分支。
  2. 邻居发现（Neighbor Discovery）
  3. 扩散（Flooding）
	 #+CAPTION: PIM-DM 扩散
	 #+ATTR_LaTeX: scale=0.75
  4. 剪枝（Prune）
- PIM-SM（ASM模型）
- PIM-SM（SSM模型）

*** 开源方案
- pimd
  1. 代码：https://github.com/troglobit/pimd
  2. 特性对比
     |-----------------+------+--------|
     | 特性            | AR   | pimd   |
     |-----------------+------+--------|
     | PIM-SM(ASM模型) | 支持 | 支持   |
     | PIM-SM(SSM模型) | 支持 | 不支持 |
     | DR竞选          | 支持 | 支持   |
     | DR发现          | 支持 | 支持   |
     | RPT构建         | 支持 | 支持   |
     | 组播源注册      | 支持 | 支持   |
     | SPT切换         | 支持 | 不支持 |
     | BSR管理域       | 支持 | 不支持 |
     |-----------------+------+--------|
  3. 配置文件
	 #+begin_src sh
     default_source_preference <preference>
     default_source_metric <metric>

     phyint <local-addr|ifname> [disable|enable]
     [altnet <network> masklen <masklen>]
     [scoped <network> masklen <masklen>]
     [threshold thr] [preference pref] [metric cost]

     cand_rp [<local-addr>] [priority <number>] [time <number>]
     cand_bootstrap_router [<local-addr>] [priority <number>]

     rp_address <rp-addr> [<group-addr> [masklen <masklen] [priority <number>]]

     group_prefix <group-addr> [masklen <masklen>] [priority <number>]

     switch_data_threshold [rate <number> interval <number>]
     switch_register_threshold [rate <number> interval <number>]
	 #+end_src
  4. 举例
	 #+begin_src ditaa :file temp/smcroute0.png
          u0                       u1                     u2
          +-------+               +--------+              +--------+
          |       |192.168.10.0/24|ipip    |192.168.1.0/24|eth0    |
          |   .100+-----=---------+.101.100+--------------+.200    |
          |   ipip|               |    eth1|              |        |
          +-------+               +--------+              +--------+          
                                                         maddr:239.100.100.100
	 #+end_src
	 - u0
	   #+begin_src sh
       ping 239.100.100.100 -I ipip -t 2
	   #+end_src
	 - u1
	   #+begin_src sh
       /etc/pimd.conf
       phyint ipip enable
       phyint br0  enable
       rp_address 192.168.10.101 224.0.0.0 masklen 4 priority 5
       group_prefix 224.0.0.0 masklen 4

       pimd -N
	   #+end_src
     - u2
	   #+begin_src sh
       /etc/pimd.conf
       phyint eth0 enable
       rp_address 192.168.10.101 224.0.0.0 maskeln 4 priority 5
       group_prefix 224.0.0.0 masklen 4

       pimd -N
       iperf -s -u -B 239.100.100.100
	   #+end_src
- pim-dm
  1. http://antc.uoregon.edu/PIMDM/pimd-dense.html
- pim from xorg
  1. https://github.com/greearb/xorp.ct/tree/master/xorp/pim
- mrd6
  1. http://fivebits.net/proj/mrd6/
- PIM Daemon for Quagga
  1. https://savannah.nongnu.org/projects/qpimd

** TODO MSDP
** 组播路由管理
*** 介绍
*** 开源方案
- 对比
    |----------------+------+--------|
    | 特性           | AR   | Linux  |
    |----------------+------+--------|
    | 组播路由和转发 | 支持 | 支持   |
    | RPF检查        | 支持 | 支持   |
    | 组播静态路由   | 支持 | 支持   |
    | 改变RPF路由    | 支持 | 不支持 |
    | 衔接RPF路由    | 支持 | 不支持 |
    | 组播负载分担   | 支持 | 不确定 |
    | 组播Over GRE   | 支持 | 支持   |
    | MPing          | 支持 | 支持   |
    | MTrace         | 支持 | 不支持 |
    | 组播多实例     | 支持 | 不确定 |
    |----------------+------+--------|

** TODO 组播网管
   
* TODO MPLS配置
* TODO VPN配置
* TODO WLAN-FAT AP配置
* TODO WLAN-AC配置
* TODO 语音配置
* TODO 可靠性配置
* TODO 安全配置
* TODO QoS配置
* TODO 网络管理和监控
* TODO 设备虚拟化
* TODO 数据中心特性
* TODO Smart Link & Monitor Link
* 参考
- 《AR150&160&200&1200&2200&3200 产品文档》
- Linux Manual: ntpd(8)
- Linux Manual: ntp.conf(5)
- Linux Manual: ntpdate(8)
- Linux Manual: ntp-keygen(8)
- Linux Manual: TERMIOS(3)
- Linux-kernel-3.8/Documentation/networking/generic-ppp.txt
- Linux-kernel-3.8/Documentation/networking/generic-hdlc.txt
- Linux-kernel-3.8/Documentation/networking/vxlan.txt
- Linux Manual: dhclient(8)
- Linux Manual: dhclient.conf(8)
- Linux Manual: nskookup(8)
- Linux Manual: resolv.conf(5)
- Linux Manual: hosts(5)
- Linux Manual: dnsmasq(8)
- Linux Manual: iptables(8)
- Linux Manual: pppd(8)
- Linux Manual: pppoe(8)
- Linux Manual: pppoe-server(8)
- Linux Manual: ifconfig(8)
- Linux Manual: ip(8)
- Linux Manual: route(8)
- http://www.nongnu.org/quagga/docs/docs-info.html
- Linux Manual: smcroute(8)
- Linux Manual: pimd(8)
